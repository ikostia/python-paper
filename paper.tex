\documentclass[a4paper, 12pt]{article}

\usepackage{mathtext}
\usepackage[OT1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,ukrainian]{babel}

\begin{document}

\section{Вступ}

\subsection{Про цей документ}

Цей документ є аналітичним звітом, створеним на вимогу викладача на факультеті кібернетики у Київському
національному університеті. Інформацію, надану у цьому документі не може бути використано у якості посилання на
авторитетне джерело. Усі точки зору, приведені нижче, є виключно точками зору автора і не претендують ні на яку
абсолютність (хоча й мають під собою певний досвід програмування). Усі висновки, котрі читач робить із цього
документу, він робить на свій страх і ризик.

У документі планується розглянути основні риси стандарту мови, систему версіонування із її двома основними
гілками: 2.x та 3.x, різноманітні реалізації: стандратний CPython, реалізація для JVM Jython, реалізація для 
.NET IronPyton, реалізація Pyton на Python під назвою PyPy, реалізація Pyton із підтримкою мікропотоків Stackless. Крім того, буде розглянуто систему розширень мови Python під назваою Cython.

\subsection{Мова Python}

Мова Python (читається [п\'{а}йтон], у спільноті слов'яномовних програмістів 
часто зустрічається вимова [піт\'{о}н])-- 
це інтерпретовна, мультипарадигменна мова загального призначення із сильною,
динамічною типізацією. Під сильною типізацією мови Python розуміється той факт, що у кожен коткретний момент
виконання кожна змінна має чітко визначений тип. Неявні приведення типів допускаються. Під динамічною типізацією
мови Python мається на увазі той факт, що типи змінних визначаються у процесі виконання програми (так званому,
рантаймі), на противагу моменту компіляції у мов із статичною типізацією. Під мультипарадигменністю мови мається
на увазі присутність (і заохочуваність) у програмуванні мовою Python використання та змішування трьох парадигм:
об'єктно-орієнтованої, функціональної та структурної.

Попри те, що основною нішею, у котрій використовується Python є веб-програмування, мову активно використовують і
у інших галузях програмування: обробка сигналів, математичне моделювання, програмування застосунків робочого
столу, серверні скрипти, програмування міжмовних зв'язків тощо.

Історія мови Python налічує вже понад двадцять років. Співробітник голандського інституту Ґвідо ван Россум
написав першу версію у 1990 році. Задумувалася мова як розширювана скриптова мова для розподіленої ОС Amoeba,
проте досягненнням цієї мети справа не обмежилася. Згодом, викристалізувалася ідея, що лежить в основі
мови Python: написаний код повинен бути простим, читабельним, непереобтяженим. Звісно, у кількох словах ці
рушійні ідеї описати важко, тому нижче цьому буде присвячено цілий розділ.

На сьогоднішній день (на момент березня 2012 року) мова Python займає дев'яте місце у рейтингу TIOBE,
спустившись на три позиції, порівняно із березнем 2011 року. Згідно Прозорого індексу популярності мов 
(Transparent Language Popularity Index), Python займає друге місце серед скриптових мов, поступившись 
сумнозвісному PHP. З іншого боку, рейтинги, безумовно, не вказують ані на що, окрім популярності мови,
а популярність не можна вважати достатньо адекватним критерієм якості мови. Саме тому нижче у цьому документі 
проводиться спроба навести більш контруктивну оцінку мови, включаючи її основні концепти, принципи, розвиток 
спільноти, плани подальшого розвитку та потенціал. 

\section{Загальні риси мови Python}

У цій частині приводиться спроба описати загальні концепції, що покладені у основу мови Python та саму реалізацію
цих принципів у вигляді синтаксичних та семантичних особливостей мови.

\subsection{The Zen of Python}

Дзеном пітона називають набір із дев'ятнадцяти правил, сформульваних Тімом Пітерсом (автором знаменитого алгоритму
сортування TimSort) та описуючих принципи, котрих притримуються розробники мови та котрих мають притримуватися
програмісти, що використовують мову Python у своїй діяльності. Це -- неформальні правила, тому, строго кажучи, перевірку 
будь-якого коду на відповідність їм провести неможливо. З іншого боку, досвід програмування на Python дозволяє
формулювати суб'єктивну оцінку коду відповідно до цих правил. Для того, щоб прочитати дзен пітона, достатньо надрукувати
\texttt{import this} у інтеракивному інтерпретаторі або знайти PEP-20 у Інтернеті.

Ось ці правила:
\begin{itemize}
    \item Прекрасно -- краще, ніж огидно.
    \item Явно -- краще, ніж неявно
    \item Просто -- краще, ніж складно.
    \item Складно -- краще, ніж заплутано.
    \item Однорівнево -- краще, ніж вкладено.
    \item Розсіяно -- краще, ніж густо.
    \item Читабельність рахується.
    \item Особливі випадки недостаньо особливі, щоб порушувати правила.
    \item Хоча практичність важливіша за чистоту.
    \item Помилки не повинні залишатися непоміченими.
    \item Окрім тих випадків, коли вони явно приховуються.
    \item Перед лицем двозначності потрібно опиратися спокусі гадати.
    \item Повинен бути один -- і бажано лише один -- очевидний спосіб зробити щось.
    \item Хоча, спершу він може не видаватися таким очевидним, якщо ви не голандець.
    \item Зараз -- краще за ніколи.
    \item Хоча ніколи -- часто краще за \emph{прямо} зараз.
    \item Якщо реалізацію важко пояснити, це погана ідея.
    \item Якщо реалізацію легко пояснити, вона може бути гарною ідеєю.
    \item Простори імен -- неймовірно крута ідея, їх просто необхідно використовувати!
\end{itemize}

\subsection{Принципи, покладені в основу синтаксису}
Мабуть, найвідомішою рисою мови Python є її синтаксис, у якому роль операторних дужок
виконують відступи. Іншими словами, якщо кілька операторів, що знаходяться у послідовних 
рядках, мають однакові відступи, то вони належать одному блоку. Відповідно, для оголошення
підблоку в рамках поточного блоку, достатньо збільшити відступ. Окрім того, якщо оператор
мови очікує, що після нього розпочинається новий блок, то цей оператор закінчується 
двокрапкою. Серед інших особливостей синтаксису можна виділити його прагення до
гарантування читабельності написаного коду. Прикладом можуть слугувати булеві операції `і'
та `або'. На відміну від традиції C-подібних мов позначати ці операції символами подвійного
амперсанду (\&\&) та подвійної вертикальної риски (||), пітон використовує англійські слова
and та or. Там, де компілятор може визначити рамки виразу (наприклад, в умові оператору if),
дужки не є обов'язковими (на відміну від того-ж таки C). Взагалі, читабельність та
мінімалістичність коду -- це ті два принципи, що лежать у основі синтаксису Python.

\subsection{Усе - об'єкт або система типів мови Python}
Як уже говорилося, в кожен момент часу кожна змінна має чітко визначений тип. Більше того,
кожна змінна є об'єктом, тобто екземпляром класу \texttt{object}, а вираз 
\texttt{isinstance(a, object)} є істинним при довільному значенні змінної \texttt{a}. 
Цікавим прикладом застосування є можливість отримувати документацію по функції, маючи
лише її екземпляр: 
\texttt{ len.\textunderscore\textunderscore doc\textunderscore\textunderscore } . 
Усі сутності мови пітон є посиланнями, а не
безпосередніми даними, присвоювання копіює посилання, а не вміст. 

Об'єктно-орієнтовані риси Python запозичені в основному із мов C++ та Modula-3. Система 
класів Python надає усі можливості традиційного об'єктно-орієнтованого програмування.
Зокрема, підтримується мультинаслідування, клас-нащадок може перевизначати довільні методи 
батьківського класу (або класів), метод може викликати метод батьківського класу із тим самим іменем. Класи передають динамічну структуру мови Python, вони створюються під час виконання програми та можуть бути модифіковані після створення. Якщо використовувати термінологію C++, то усі члени класів є публічними, а методи -- віртуальними. Засоби створення приватних членів існують, проте вони дають лише певні зручності при оперуванні поняттями видимості, реального приховування немає. Методи класів не мають безумовного доступу до полів об'єктів, тому вони оголошуються із явно вказаним формальним параметром, на місце котрого передається екземпляр, від імені котрого викликається метод. Більшість операторів для кожного класу можна перевизначати, для деяких операторів є ліво- та правостороннє перевизначення (оператори додавання, множення тощо).

Класи можна оголошувати без батьків, тоді вони (і всі їх нащадки) є класами \emph{старого стилю}. З іншого боку, якщо оголосити клас нащадком \texttt{object}, то він вважається класом \emph{нового стилю}. Усі класи нового стилю є екземплярами класу \texttt{type}.
На відміну від багатьох інших мов, пітон дозволяє наслідувати від вбудованих класів таких як \texttt{list} чи \texttt{dict}. 


\subsection{Елементи функціонального програмування}

\subsection{Простори імен}

\subsection{GIL}

\subsection{Відмова від реалізації хвостової рекурсії}
Пітон не підтримує оптимізацію хвостової рекурсії. Попри те, що існує ряд `хаків', котрі допомагають емулювати поведінку оптимізованої хвостової рекурсії в багатьох необхідних випадках, офіційної реалізації не буде. Ґвідо ван Россум написав про це у своєму блозі, аргументуючи таке рішення кількома аргументами. Нижче приведені деякі з них:
 \begin{itemize}
    \item Оптимізація хвостової рекурсії несумісна із гарними трейсбеками, оскільки вона порушує структуру стекових фреймів.
    \item Уявлення про те, що оптимізація хвостової рекурсії є звичайною мовною оптимізацією, яку розробники кожної імплементації пітона можуть реалізовувати чи ні на їх вибір, є хибним. Щойно цю оптимізацію почнуть реалізовувати, розробники почнуть писати код, що залежить від неї (наприклад, розрахований на велику глибину рекурсії). Цей код, звісно, не працюватиме на інших реалізація пітона, що негативно відобразиться на сумісностях усіх штибів.
    \item Ґвідо не вірить у те, що рекурсія є базисом програмування. Він визнає її важливість у якості наглядного викладацького та теоретичного інструментів, проте заперечує проти того, що вона є щоденним інструментом розробника.
 \end{itemize}


\section{Розвиток мови та спільнота Python}

\subsection{Команда ядра Python}

\subsection{Python Enhancement Proposals (PEPs)}

\subsection{Репозиторії та системи розповсюдження пакетів}

\section{Система версіонування стандартів}
Загалом, одним із принципів версіонування пітона є обернена сумісність. Їй приділяється 
справді багато уваги при проектуванні нових властивостей. З іншого боку, в певний момент 
стає очевидно, що існують проблеми, котрі потрібно вирішити і вирішити їх можна лише 
кардинально щось змінивши. Очевидно, що такі кардинальні зміни зламають обернену сумісність
і протирічитимуть початковому підходу. Задля того, щоб задовольнити водночас людей, що 
потребують мову, на котрій можна не дивлячись на зміну версій виконувати старий код та 
потреби покращення самої мови, розробники пітона підтримують дві головних гілки: 2.x та 3.x.


\subsection{Гілка 2.x}
Гілка 2.x на сьогоднішній день є версією інтерпретатора, яку вимагає більшість програмного забезпечення. Наприклад, популярний фреймворк Django на сьогоднішній день ще не підтримує Python 3. Відповідно, більшість комерційної розробки також ведеться на 2.x.
Остання стабільна на даний момент версія у гілці 2.x це Python 2.7.2, є також RC-2 версії 2.7.3.  
Задля того, щоб стимулювати перехід користувачів (та переписування бібліотек) на гілку 
Python 3, у PEP-404 було опубліковано офіційний графік не-виходу Python 2.8. Себто, версії 2
.8 не буде ніколи. 

\subsection{Гілка 3.x}
Python 3 здійснює достатньо багато обернено-несумісних змін у синтаксис та семантику мови. Серед них: \texttt{print} перетворюється на функцію із спеціального виразу, усі рядки по замовчуванню стають юнікодними, альтернативою є потоки байтів (на противагу, у другому пітоні рядки поділялися на юнікодні та 8-бітові, причому по замовчуванню рядок вважався саме 8-бітовим), додана можливість присвоювати нові значення змінним із зовнішніх просторів імен з допомогою нового ключового слова \texttt{nonlocal} у додачу до вже існуючого \texttt{global}, додана можливість оголошувати множини з допомогою простого перелічення елементів у фігурних дужках: \texttt{\{1,2,3\}}, та багато іншого.

Багато популярних бібліотек, наприклад, Flask, Jinja, Numpy, Scipy тощо, вже підтримують Python 3. Для менш болісної міграції існуючого програмного забезпечення на третю версію пітона, розроблено спеціальну утиліту під назвою 2to3, котра дозволяє велику кількість несумісностей виправити автоматично.

\section{Реалізації Python}

\subsection{CPython}

\subsection{Jython}

\subsection{IronPython}

\subsection{PyPy}

\subsection{Stackless}

\section{Системи розширень та доступу до зовнішніх бібліотек}

\subsection{Cython}

\subsection{ctypes}

\end{document}