\documentclass[a4paper, 12pt, onsedie]{article}

\usepackage{mathtext}
\usepackage[OT1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{indentfirst}
\usepackage{misccorr}
\usepackage[english,ukrainian]{babel}
\usepackage[margin=2.5cm]{geometry}
\usepackage[pdftex]{graphicx}

\begin{document}

\begin{titlepage}
    \begin{center}
        \normalsize{
            Міністерство освіти і науки України\\
            Київський національний університет імені Тараса Шевченка\\
            Факультет кібернетики\\[4.0cm]
        }
        \Huge{Аналітичний звіт із дослідження екосистеми мови Python}\\[9.0cm]
        \large{
            \begin{flushright}
                \parbox[position=right]{230px}{
                    Виконав\\
                    магістр першого курсу\\
                    кафедри математичної інформатики\\
                    \textit{Балицький Костянтин}
                }
            \end{flushright}
        }

        \vfill{\normalsize{Київ -- 2012}}
    \end{center}
\end{titlepage}

\tableofcontents
\pagebreak

\section{Вступ}

\subsection{Про цей документ}

    Цей документ є аналітичним звітом, створеним на вимогу викладача на факультеті кібернетики у Київському
    національному університеті. Інформацію, надану у цьому документі не може бути використано у якості посилання на
    авторитетне джерело. Усі точки зору, приведені нижче, є виключно точками зору автора і не претендують ні на яку
    абсолютність (хоча й мають під собою певний досвід розробки). Усі висновки, котрі читач робить із цього
    документу, він робить на свій страх і ризик.

    У документі планується розглянути основні риси стандарту мови, систему версіонування із її двома основними
    гілками: 2.x та 3.x, різноманітні реалізації: стандратний CPython, реалізація для JVM Jython, реалізація для 
    .NET IronPyton, реалізація Pyton на Python під назвою PyPy, реалізація Pyton із підтримкою мікропотоків Stackless. 
    Крім того, буде розглянуто систему розширень мови Python під назваою Cython.

    \subsection{Кому варто читати цей документ}
    Якщо ви -- людина, що хоче почати вивчення мови Python, вам не варто розраховувати на цей документ як
    на навчальний посібник. Усі риси мови, що тут описано, описано радше із порівняльної та описової точок
    зору, аніж із дидактичної. Якщо, крім цього, ви взагалі не маєте досвіду у програмуванні, а натомість
    вирішили вивчати мову Python у якості своєї першої мови, вам \emph{взагалі} не рекомендовано читати цей
    документ, оскільки, знову ж таки, порівняння не лише програмування, а й процесів, що проходять у екосистемі
    мови Python із такими у інших мовах (принаймні, неявне порівняння) було однією із рушійних ідей документу.

    В свою чергу, якщо ви -- програміст, що має досвід із професійною розробкою іншими мовами, і бажаєте
    поглянути на екосистему Python ззовні (скажімо, щоб вирішити, чи варто занурюватися у вивчення мови),
    цей документ для вас. Аналогічно, якщо ви вже маєте певний досвід розробки мовою Python, у цьому документі
    ви, можливо, все ж таки матимете змогу знайти щось цікаве.

\subsection{Мова Python}

    Мова Python (читається [п\'{а}йтон], у спільноті слов'яномовних програмістів 
    часто зустрічається вимова [піт\'{о}н])-- 
    це інтерпретовна, мультипарадигменна мова загального призначення із сильною,
    динамічною типізацією. Під сильною типізацією мови Python розуміється той факт, що у кожен конкретний момент
    виконання кожна змінна має чітко визначений тип. Неявні приведення типів допускаються. Під динамічною типізацією
    мови Python мається на увазі той факт, що типи змінних визначаються у процесі виконання програми (так званому,
    рантаймі), на противагу моменту компіляції у мов із статичною типізацією. Під мультипарадигменністю мови мається
    на увазі присутність (і заохочуваність) у програмуванні мовою Python використання та змішування трьох парадигм:
    об'єктно-орієнтованої, функціональної та структурної.

    Попри те, що основною нішею, у котрій використовується Python є програмування під веб, мову активно використовують і
    у інших галузях програмування: обробка сигналів, математичне моделювання, програмування застосунків робочого
    столу, серверні скрипти, програмування міжмовних зв'язків тощо.

    Історія мови Python налічує вже понад двадцять років. Співробітник голандського інституту Ґвідо ван Россум
    написав першу версію у 1990 році. Задумувалася мова як розширювана скриптова мова для розподіленої ОС Amoeba,
    проте досягненнням цієї мети справа не обмежилася. Згодом, викристалізувалася ідея, що лежить в основі
    мови Python: написаний код повинен бути простим, читабельним, непереобтяженим. Звісно, у кількох словах ці
    рушійні ідеї описати важко, тому нижче цьому буде присвячено цілий розділ.

    На сьогоднішній день (на момент березня 2012 року) мова Python займає дев'яте місце у рейтингу TIOBE,
    спустившись на три позиції, порівняно із березнем 2011 року. Згідно Прозорого індексу популярності мов 
    (Transparent Language Popularity Index), Python займає друге місце серед скриптових мов, поступившись 
    сумнозвісному PHP. З іншого боку, рейтинги, безумовно, не вказують ані на що, окрім популярності мови,
    а популярність не можна вважати достатньо адекватним критерієм якості мови. Саме тому нижче у цьому документі 
    проводиться спроба навести більш контруктивну оцінку мови, включаючи її основні концепти, принципи, розвиток 
    спільноти, плани подальшого розвитку та потенціал. 

\section{Загальні риси мови Python}
    У цій частині приводиться спроба описати загальні концепції, що покладені у основу мови Python та саму реалізацію
    цих принципів у вигляді синтаксичних та семантичних особливостей мови.

\subsection{The Zen of Python}
    Дзеном пітона називають набір із дев'ятнадцяти правил, сформульваних Тімом Пітерсом (автором знаменитого алгоритму
    сортування TimSort) та описуючих принципи, котрих притримуються розробники мови та котрих мають притримуватися
    програмісти, що використовують мову Python у своїй діяльності. Це -- неформальні правила, тому, строго кажучи, перевірку 
    будь-якого коду на відповідність їм провести неможливо. З іншого боку, досвід програмування на Python дозволяє
    формулювати суб'єктивну оцінку коду відповідно до цих правил. Для того, щоб прочитати дзен пітона, достатньо надрукувати
    \texttt{import this} у інтеракивному інтерпретаторі або знайти PEP-20 у Інтернеті.

    Ось ці правила:
    \begin{itemize}
        \item Красиве -- краще, ніж потворне.
        \item Явне -- краще, ніж неявне
        \item Просте -- краще, ніж складне.
        \item Складне -- краще, ніж заплутане.
        \item Однорівневе -- краще, ніж вкладене.
        \item Розділене -- краще, ніж цільне.
        \item Читабельність має значення.
        \item Виключення недостатньо виключні, щоб порушувати правила.
        \item Хоча практичність важливіша за чистоту.
        \item Помилки слід замовчувати.
        \item Окрім тих випадків, коли вони явно замовчуються.
        \item Перед лицем неоднозначності варто опиратися спокусі гадати.
        \item Повинен бути один -- і бажано лише один -- очевидний спосіб зробити щось.
        \item Хоча, спершу він може не видаватися таким очевидним, якщо ви не голандець.
        \item Зараз -- краще за ніколи.
        \item Хоча ніколи -- часто краще за \emph{прямо} зараз.
        \item Якщо реалізацію важко пояснити, це погана ідея.
        \item Якщо реалізацію легко пояснити, вона може бути гарною ідеєю.
        \item Простори імен -- геніальна ідея, що більше, то краще!
    \end{itemize}

\subsection{Принципи, покладені в основу синтаксису}
    Мабуть, найвідомішою рисою мови Python є її синтаксис, у якому роль операторних дужок
    виконують відступи. Іншими словами, якщо кілька операторів, що знаходяться у послідовних 
    рядках, мають однакові відступи, то вони належать одному блоку. Відповідно, для оголошення
    підблоку в рамках поточного блоку, достатньо збільшити відступ. Окрім того, якщо оператор
    мови очікує, що після нього розпочинається новий блок, то цей оператор закінчується 
    двокрапкою. Приведемо приклад оголошення функції для демонстрації двох вищеописаних
    особливостей:

    \begin{verbatim}
    def compute(n):
        a = range(n)
        b = [i**2 for i in a]
        return sum(b)
    \end{verbatim}

    Серед інших особливостей синтаксису можна виділити його прагення до
    гарантування читабельності написаного коду. Прикладом можуть слугувати булеві операції ``і''
    та ``або''. На відміну від традиції C-подібних мов позначати ці операції символами подвійного
    амперсанду (\&\&) та подвійної вертикальної риски (||), пітон використовує англійські слова
    and та or. Там, де компілятор може визначити рамки виразу (наприклад, в умові оператору if),
    дужки не є обов'язковими (на відміну від того-ж таки C). Підтримуються двосторонні чисельні
    порівняння:

    \begin{verbatim}
    if a in lst and (b is not None or 7 < c <= 10):
        pass
    \end{verbatim}

    Взагалі, читабельність та
    мінімалістичність коду -- це ті два принципи, що лежать у основі синтаксису Python.

\subsection{Усе - об'єкт або система типів мови Python}
    Як уже говорилося, в кожен момент часу кожна змінна має чітко визначений тип. Більше того,
    кожна змінна є об'єктом, тобто екземпляром класу \texttt{object}, а вираз 
    \texttt{isinstance(a, object)} є істинним при довільному значенні змінної \texttt{a}. 
    Причому, зміннна \texttt{a} є змінною у більш широкому розумінні, ніж у традиційних
    мовах, таких як C або Java. Фактично, змінною може бути модуль, функція, клас,
    що завгодно. Практично, пітон втілює ідею, що кожна сутність, з якою він працює, є 
    екземпляром деякого класу. Нижче приведено декілька цікавих прикладів застосування
    цієї ідеї.

    Інтроспекція функції:

    \begin{verbatim}
    def mycoolfunc(param):
        """This function does nothing"""
        return param

    print mycoolfunc.__doc__ # надрукує внутрішню документацію функції
    code = mycoolfunc.__code__ # запише у змінну code об'єкт коду функції
    \end{verbatim}

    Інтроспекція модуля:

    \begin{verbatim}
    import itertools
    print itertools.__file__ # файл, у котрому зберігається модуль
    \end{verbatim}

    Інтроспекція класу:

    \begin{verbatim}
    class B(type):
        pass

    class C(object):
        pass

    class A(list, C):
        __metaclass__ = B

    print A.__bases__ # надрукує кортеж базових класів (list, C, )
    print A.__metaclass__ # надрукує метаклас класу A - B
    print B.__class__ # надрукує type, адже клас B є екземпляром класу type
    print A.__class__ # надрукує B, адже ми перевизначили метаклас A
    \end{verbatim}

    Усі сутності мови Python є посиланнями, а не
    безпосередніми даними, присвоювання копіює посилання, а не вміст. 

    Об'єктно-орієнтовані риси Python запозичені в основному із мов C++ та Modula-3. Система 
    класів Python надає усі можливості традиційного об'єктно-орієнтованого програмування.
    Зокрема, підтримується мультинаслідування, клас-нащадок може перевизначати довільні методи 
    батьківського класу (або класів), метод може викликати метод батьківського класу із тим 
    самим іменем. Класи передають динамічну структуру мови Python, вони створюються під час 
    виконання програми та можуть бути модифіковані після створення. Якщо використовувати 
    термінологію C++, то усі члени класів є публічними, а методи -- віртуальними. Засоби 
    створення приватних членів існують, проте вони дають лише певні зручності при оперуванні 
    поняттями видимості, реального приховування немає. Методи класів не мають безумовного 
    доступу до полів об'єктів, тому вони оголошуються із явно вказаним формальним параметром, 
    на місце котрого передається екземпляр, від імені котрого викликається метод (традиційно
    цей параметр називають \texttt{self}, проте обмеження на його ім'я не накладаються).
    Більшість 
    операторів для кожного класу можна перевизначати, для деяких операторів є ліво- та 
    правостороннє перевизначення (оператори додавання, множення тощо).

    Класи можна оголошувати без батьків, тоді вони (і всі їх нащадки) є класами 
    \emph{старого стилю}. З іншого боку, якщо оголосити клас нащадком \texttt{object}, то він 
    вважається класом \emph{нового стилю}. Усі класи нового стилю є екземплярами класу 
    \texttt{type}. Загалом, використання класів старого стилю вважається застарілою практикою,
    і у гілці Python 3.x вони просто відсутні.

    Оскільки класи також є об'єктами, то можна визначити класи, чиїми екземплярами є ці об'єкти.
    Якщо мова йде про класи старого стилю, то вони є екземплярами класу \texttt{classobj} (знову
    таки, нагадуємо, що використання класів старого стилю є поганою практикою). Щодо класів 
    нового стилю, то для них можливі два варіатни поведінки. Перший -- клас оголошується без 
    метакласу. Тоді він стає екземпляром класу \texttt{type}:
    \begin{verbatim}
    class A(B, C, D):
        pass

    print type(A) # надрукує type
    \end{verbatim}
    Другий варіант -- метаклас вказується явно. Тоді він і є класом, екземпляром котрого є наш
    клас:
    \begin{verbatim}
    class A(B,C,D):
        __metaclass__ = E

    print type(A) # надрукує E
    \end{verbatim}

    На відміну від багатьох інших мов, пітон дозволяє наслідувати від вбудованих класів таких 
    як \texttt{list} чи \texttt{dict}, проте не від усіх. Наприклад, зробити клас-нащадок класу
    \texttt{bool} не вдасться. Звідси природнім чином випливає питання -- чи дозволяє Python
    створювати ``фінальні'' (у термінології Java) класи. Відповідь на це питання -- ні. Але це
    ``ні'' у сенсі стандартних можливостей інтерпритатора, скажімо -- ключових слів чи чогось
    подібного. Проте, використання концепту метакласів дозволяє заборонити наслідування.
    Скажімо, код:

    \begin{verbatim}
    class Final(type):
      def __new__(cls, name, bases, classdict):
        for b in bases:
          if isinstance(b, Final):
            raise TypeError("type %r is not an "\
                "acceptable base type" % b.__name__)
        return type.__new__(cls, name, bases, classdict)

    class A(object):
      __metaclass__ = Final

    class B(A): pass
    \end{verbatim}
    видаватиме при спробі оголосити клас \texttt{B} помилку:

    \begin{verbatim}
    Traceback (most recent call last):
      File "1.py", line 11, in <module>
        class B(A): pass
      File "1.py", line 5, in __new__
        raise TypeError("type %r is not an acceptable base type" % b.__name__)
    TypeError: type 'A' is not an acceptable base type
    \end{verbatim}

    Вбудовані типи та фунцкції мови Python знаходяться у ``віртуальному'' модулі
    \texttt{ \textunderscore \textunderscore builtin\textunderscore \textunderscore }. Імпортувати цей
    модуль, звісно, не потрібно. Він містить достатньо велику кількість 
    базових елементів мови. Найцікавиіші з них -- стандартні ітераційні типи
    \texttt{list}, \texttt{dict}, \texttt{tuple}, \texttt{set} та функції для 
    маніпуляцій з ними -- будуть розглянуті у наступному розділі. 

\subsection{Елементи функціонального програмування}
    Наявність списку (\texttt{list}) та інших ітераційних типів в якості вбудованих
    у мову Python та інструментів для зручної обробки таких ітераторів дає широкі можливості
    для розвитку функціональних елементів у програмах мовою Python. На практиці виходить, що
    програми, написані із використанням функціонального стилю у тих місцях, де це припустимо,
    краще читаються та часто-густо швидше працюють. Читабельність досягаєтсья за рахунок
    лаконічності та загальної звички спільноти використовувати функціональний стиль. Швидкість
    -- за рахунок того, що функціональні елементи виконуються як одне ціле і тому виконуються
    на рівні C. Аналогічні реалізації з допомогою циклів набагато більшу частину коду
    виконують на рівні Python, що, очевидно, повільніше. Основними функціональними елементами
    мови Python є ітератори та генератори.

    Ітератор (грубо кажучи - інтерфейс списку) -- це структура даних, що дає можливість 
    послідовно, із строго визначеним порядком перебирати її елементи. Якщо говорити інакше,
    ітератором -- це така структура, котру можна підставити у цикл \texttt{for}:

    \begin{verbatim}
    for i in range(10):
        pass
    \end{verbatim}
    В даному прикладі функція \texttt{range(10)} повертає список із десяти елементів, а цей
    список реалізує інтерфейс ітератора. Використання ітераторів у функціональному стилі має
    назву ``охоплення списків'' (list comprehension) і полягає у швидкому конструюванні нових
    списків із існуючих ітераторів. Наприклад, для того, щоб створити список із квадратів 
    усіх натуральних чисел від нуля до десяти, достатньо написати:

    \begin{verbatim}
    l = [i*i for i range(10)]
    \end{verbatim}
    Для того, щоб створити список із квадратів парних чисел можна написати:
    \begin{verbatim}
    l = [i*i for i in range(10) if i%2 == 0]
    \end{verbatim}

    Для зручної маніпуляції списками та іншими ітераторами у модулі 
    \texttt{\textunderscore \textunderscore builtin\textunderscore \textunderscore }
    мови Python передбачено велику кількість ``спискових'' функцій: \texttt{map()}, 
    \texttt{filter()}, \texttt{all()}, \texttt{any()}, \texttt{max()}, \texttt{min()},
    \texttt{reduce()}, \texttt{sum()}. Поєднання цих двох механізмів -- ітераторів
    та функцій такого типу -- дає широкі можливості для лаконічних та потужних
    виразів для обробки списків.

    Іншим важливим концептом, що відносять до функціонального стилю, є генератори. 
    Генератор -- це засіб для створення ітератору, проте, на відміну від спискових
    ітераторів він позбавлений деяких обмежень. Крім цього, генератори є реалізацією
    концепту \emph{потоків}, як вони описані у класичній книжці Structure and 
    Interpretation of Computer Programs. Досягається ця реалізація за допомогою
    \emph{відкладених обчислень}, можливість для котрих надають генератори. Іншим
    класичним прикладом застосування генераторів є \emph{спів-процедури} 
    (\emph{co-routines}). Так яким же чином досягаються усі ці можливості?

    Генератор у мові Python -- це функція, що має можливість припиняти своє виконання
    і згодом продовжувати його з попереднього місця. Для цього у мові передбачене 
    спеціальне ключове слово \texttt{yield}. Ось приклад функції, котра повертає 
    генератор усіх чисел, починаючи з деякого:
    \begin{verbatim}
    def count(n):
        while True:
            yield n
            n = n + 1
    \end{verbatim}
    Варто звернути увагу на те, що у самій функції виконується нескінченний цикл, тому,
    в класичному розумінні, функція ніколи не завершить свого виконання. Проте, щоразу,
    як у об'єкта, котрий створює ця функція (у генератора) викликатимуть метод 
    \texttt{next()}, функція отримуватиме потік виконання і виконуватиметься від 
    попереднього місця, на котрому вона припинила своє виконання до наступного 
    \texttt{yield}. Зрозуміло, що генератори задають не стільки послідовність, скільки
    спосіб її побудови. Саме тому вони надають можливість реалізовувати ідею відкладених
    обчислень. Скінченні генератори легко перетворювати на списки:
    \begin{verbatim}
    def step(n, m, s):
        while n<=m:
            yield n
            n = n + s

    a = [i for i in step(0, 10, 3)]
    \end{verbatim}

    Аналогічно до ідеї охоплення списків, існують подібні конструкції для
    генераторів. Називаються такі конструкції \emph{генераторними виразами} 
    (\emph{generator expressions}) і будуються аналогічно до спискових, за
    виключенням того, що використовуються круглі дужки замість квадратних.
    Для прикладу уявімо вже відомий нам генератор \texttt{count(n)} та 
    створимо на його основі генератор, що повертає квадрати чисел, кратних
    трьом:
    \begin{verbatim}
    g = (i*i for i in count(1) if i%3 == 0)

    for i in xrange(3): 
        print g.next()

    # надруковано буде числа 9, 36 та 81
    \end{verbatim}

    Знову таки, як і для списків, є певна кількість функцій, що спрощують
    маніпуляції з ітераторами, що підтримують також і генератори. 
    Більшість із них знаходиться у модулі \texttt{itertools}:
    \texttt{imap}, \texttt{islice}, \texttt{izip} тощо.

\subsection{Простори імен}

\subsection{GIL}
    Відомою особливістю мови Python є її реалізація потоків та проблеми, пов'язані з цією
    реалізацією. Справа в тому, що інтерпретатор мови не є thread-safe кодом, отже забороняє
    виконання двох потоків у рамках одного інтерпретатора одночасно. В даному випадку під
    забороною виконання одночасно мається на увазі той факт, що в інтерпретаторі існує
    механізм синхронізації, що зветься Global Interpreter Lock (GIL), тобто, глобальний `лок'
    інтерпретатора. Щоразу, коли виконується якийсь потік, він захоплює цей лок ексклюзивно,
    тому інші потоки виконуватися не можуть. Причина цього, як уже було сказано, у тому, що
    сам код інтерпретатора писався без розрахунку на багатопотокове виконання. 

    Проте, не дивлячись на наявність GIL, Python підтримує багатопотоковість. Очевидно, що
    на цю багатопотоковість GIL накладає суттєві обмеження. Перше і найголовніше -- 
    багатопотокові програми \emph{принципово не отримують переваг у швидкості}
    від багатопроцесорної архітектури комп'ютера. Тому, якщо розробник має на меті 
    використовувати багатопроцесорну архітектуру для розподілених обчислень та бажає
    використовувати при цьому мову Python, він мусить користуватися процесами, а не потоками.
    Загалом, це не таке вже і серйозне обмеження, оскільки багатопроцесовість насправді мало
    чим поступається багатопотоковості. Особливо, в рамках однієї машини.

    На жаль, вищевказане обмеження не є єдиною особливістю, котру привносить у програмування
    мовою Python GIL. Насправді, виявляється, що багатопотокові програми не лише не працюють
    швидше за аналогічні однопотокові, а працюють навіть повільніше. Причому, коефіціент
    сповільнення зростає разом із зростанням кількості потоків та кількості процесорів.
    Причини такого явища криються у реалізації багатопотоковості Python. Справа в тому, що
    на відміну від потоків Java або cthreads, інтерпретатор Python не має своїх механізмів
    розподілу часу, синхронізації та ін. Менеджмент потоків здійснює операційна система.
    Інтерпретатор же просто захоплює та відпускає GIL при кожному переключенні контексту.
    Якщо потік, скажімо, отримав статус sleep внаслідок очікування вводу-виводу, 
    інтерпретатор Python спробує стимулювати операційну систему до перерозподілу процесорного
    часу, тобто, `натякне' їй, що варто зробити context switch. Крім цього, інтерпретатор
    Python 2.x звільняє (release) GIL кожних 100 `тіків' 
    (спеціальна одиниця виконання програми, що грубо співпадає із інструкцією інтерпритатора).
    Після кожного такого звільнення операційна система намагається перерозподілити процесорний
    час і той потік, що першим встиг захопити GIL виконується далі. Варто звернути увагу, що
    інтервал у 100 `тіків' -- дуже нестабільний вимір часу.


\subsection{Відмова від реалізації хвостової рекурсії}
    Пітон не підтримує оптимізацію хвостової рекурсії. Попри те, що існує ряд ``хаків'', котрі
    допомагають емулювати поведінку оптимізованої хвостової рекурсії в багатьох необхідних
    випадках, офіційної реалізації не буде. Ґвідо ван Россум написав про це у своєму блозі,
    аргументуючи таке рішення кількома аргументами. Нижче приведені деякі з них:
     \begin{itemize}
        \item Оптимізація хвостової рекурсії несумісна із гарними трейсбеками, оскільки вона
        порушує структуру стекових фреймів.
        \item Уявлення про те, що оптимізація хвостової рекурсії є звичайною мовною 
        оптимізацією, яку розробники кожної імплементації пітона можуть реалізовувати чи ні на 
        їх вибір, є хибним. Щойно цю оптимізацію почнуть реалізовувати, розробники почнуть 
        писати код, що залежить від неї (наприклад, розрахований на велику глибину рекурсії). 
        Цей код, звісно, не працюватиме на інших реалізація пітона, що негативно відобразиться 
        на сумісностях усіх видів.
        \item Ґвідо не вірить у те, що рекурсія є базисом програмування. Він визнає її 
        важливість у якості наглядного викладацького та теоретичного інструментів, проте 
        заперечує проти того, що вона є щоденним інструментом розробника.
     \end{itemize}


\section{Розвиток мови та спільнота Python}

\subsection{BDFL}
    Важливою рисою розвитку мови програмування Python 

\subsection{Python Enhancement Proposals (PEPs)}

\subsection{Репозиторії та системи розповсюдження пакетів}

\section{Система версіонування стандартів}
Загалом, одним із принципів версіонування пітона є обернена сумісність. Їй приділяється 
справді багато уваги при проектуванні нових властивостей. З іншого боку, в певний момент 
стає очевидно, що існують проблеми, котрі потрібно вирішити і вирішити їх можна лише 
кардинально щось змінивши. Очевидно, що такі кардинальні зміни зламають обернену сумісність
і протирічитимуть початковому підходу. Задля того, щоб задовольнити водночас людей, що 
потребують мову, на котрій можна не дивлячись на зміну версій виконувати старий код та 
потреби покращення самої мови, розробники пітона підтримують дві головних гілки: 2.x та 3.x.


\subsection{Гілка 2.x}
Гілка 2.x на сьогоднішній день є версією інтерпретатора, яку вимагає більшість програмного
забезпечення. Наприклад, популярний фреймворк Django на сьогоднішній день ще не підтримує
Python 3. Відповідно, більшість комерційної розробки також ведеться на 2.x.
Остання стабільна на даний момент версія у гілці 2.x це Python 2.7.2, є також RC-2 версії 2.7.3.
Задля того, щоб стимулювати перехід користувачів (та переписування бібліотек) на гілку 
Python 3, у PEP-404 було опубліковано офіційний графік не-виходу Python 2.8. Себто, версії 2
.8 не буде ніколи. 

\subsection{Гілка 3.x}
Python 3 здійснює достатньо багато обернено-несумісних змін у синтаксис та семантику мови.
Серед них: \texttt{print} перетворюється на функцію із спеціального виразу, усі рядки по
замовчуванню стають юнікодними, альтернативою є потоки байтів (на противагу, у другому
пітоні рядки поділялися на юнікодні та 8-бітові, причому по замовчуванню рядок вважався
саме 8-бітовим), додана можливість присвоювати нові значення змінним із зовнішніх просторів
імен з допомогою нового ключового слова \texttt{nonlocal} у додачу до вже існуючого 
\texttt{global}, додана можливість оголошувати множини з допомогою простого перелічення
елементів у фігурних дужках: \texttt{\{1,2,3\}}, та багато іншого.

Багато популярних бібліотек, наприклад, Flask, Jinja, Numpy, Scipy тощо, вже підтримують
Python 3. Для менш болісної міграції існуючого програмного забезпечення на третю версію
пітона, розроблено спеціальну утиліту під назвою 2to3, котра дозволяє велику кількість
несумісностей виправити автоматично.

\section{Реалізації Python}
Оскільки сам Python кожної версії можна розглядати як стандарт, накладений на синтаксис та
семантику мови і API стандартної бібліотеки, то з'являється природний простір для ``маневру''
 -- багатьох можливих реалізацій стандарту. Що, власне, і відбувається.

\subsection{CPython}
CPython -- реалізація стандарту мови Python на C -- є головною реалізацією. Власне, сам
стандрат Python і ототожнюється із CPython. CPython завжди містить найновішу версію пітона 
у кожній із двох мажорних гілок. Розробляється CPython так званою Python core team -- 
командою ядра пітона, котру буде описано нижче.


\subsection{Jython}
Jython - реалізація мови Python на мові Java, котра дозволяє використовувати класи Java у 
Python-скриптах та компілюється у байт-код JVM. Однією із визначних відмінностей Jython від
CPython є відсутність у першому сумнозвісного GIL, відповідно, повноцінна підтримка 
багатопоточності. Серед інших відмінностей, варто згадати заміну у Jython пітонівського 
збирача сміття на такий самий із JVM.
Цікаво, що популярний веб-фреймворк Django має спеціальний проект Django-Jython, котрий на
сьогоднішній день надає версію коду Django 1.3.x, що може виконуватися на Jython.
Остання стабільна версія стандарту Python, реалізована у вигляді Jython -- 2.5.2, у стані 
бета-тестування перебуває версія 2.5.3b1.

\subsection{IronPython}
IronPython -- реалізація Python для фреймворку .NET. Код IronPython, відповідно, може 
використовувати класи .NET та компілюється у CIL. Цікаво, що реалізація IronPython є 
програмним забезпеченням з відкритим вихідним кодом. Версія пітона, що реалізована на даний 
момент -- 2.6.

\subsection{PyPy}
PyPy -- це версія мови Python, написана на мові Python. Причому, вона написана на спеціальній 
підмножині мови пітон, що називається RPython (Restricted Python, обмежений Python). Одна 
із найбільш вагомих рис версії полягає в тому, що вона додає JIT-компілятор до Python, і за 
рахунок цього велика кількість коду працює на PyPy у рази швидше, ніж на чистому CPython. 
Крім того, стверджується, що PyPy має кращі показники щодо використання пам'яті та має 
можливості для запуску так званого ненадійного коду (untrusted code) у пісочниці (sandbox) 
без небезпеки. Багато існуючих бібліотек, наприклад, Django, Twisted та Flask підтримуються 
PyPy. Також, ведеться активна робота над підтримкою NumPy.

Остання реалізована версія стандарту у PyPy -- 2.7.2.

\subsection{Stackless}
Stackless Python - модифікована версія мови програмування Python, що привносить у мову
можливість використання мікропотоків, уникаючи проблем швидкодії та складнощів, що виникають
у традиційних потоках. Stackless Python дає можливість використовувати наступні структури:
\begin{itemize}
    \item Мікропотоки. (microthreads) ``Задачі'' (tasklets) обгортають функції, дозволяючи їм 
          потім бути об'єднаними у мікропотоки.
    \item Канали (channels) використовуються для двосторонньої комунікації між задачами.
    \item Планувальник (scheduler) системи round-robin. Застосовується для планування
          задач виходячи із або попереджуючої (preemptive), або співробітницької (cooperative) 
          парадигм мультипрограмування.
    \item Серіалізатори використовуються для збереження задач на диск для подальшого виконання.
\end{itemize}

Останні версії, підтримувані Stackless у обох гілках: Python 2.7.2 та Python 3.2.2.

\section{Системи розширень та доступу до зовнішніх бібліотек}

\subsection{Cython}

\subsection{ctypes}

\end{document}